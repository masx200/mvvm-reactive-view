{"version":3,"file":"index.min.js","sources":["index.js"],"sourcesContent":["const globalThis = Function(\"return this\")();\n\nconst self = globalThis;\n\nconst window = globalThis;\n\nconst global = globalThis;\n\nconst {WeakSet: WeakSet, WeakMap: WeakMap, Date: Date, RegExp: RegExp, Event: Event, requestAnimationFrame: requestAnimationFrame, URL: URL, Blob: Blob, Element: Element, Node: Node, String: String, Array: Array, document: document, Object: Object, Reflect: Reflect, Proxy: Proxy, Symbol: Symbol, Boolean: Boolean, Promise: Promise, Set: Set, Math: Math, Error: Error, TypeError: TypeError, JSON: JSON, Map: Map, clearTimeout: clearTimeout, setTimeout: setTimeout, parseInt: parseInt} = globalThis;\n\nfunction isprimitive(a) {\n    return isstring(a) || isnumber(a) || isboolean(a) || isundefined(a) || isbigint(a);\n}\n\nfunction isbigint(a) {\n    return typeof a === \"bigint\";\n}\n\nfunction issymbol(a) {\n    return typeof a === \"symbol\";\n}\n\nconst isplainobject = a => isobject(a) && gettagtype(a) === \"Object\";\n\nfunction isundefined(a) {\n    return !a && a === void 0 || a === null;\n}\n\nfunction isnumber(a) {\n    return typeof a === \"number\";\n}\n\nfunction isboolean(a) {\n    return typeof a === \"boolean\";\n}\n\nfunction isobject(a) {\n    return typeof a === \"object\" && a !== null;\n}\n\nfunction isstring(a) {\n    return typeof a === \"string\";\n}\n\nfunction isfunction(a) {\n    return typeof a === \"function\";\n}\n\nfunction isarray(a) {\n    return Array.isArray(a) && a instanceof Array;\n}\n\nfunction gettagtype(a) {\n    return {}.toString.call(a).replace(\"[object \", \"\").replace(\"]\", \"\").trim();\n}\n\nfunction isSet(a) {\n    return a instanceof Set;\n}\n\nfunction isMap(a) {\n    return a instanceof Map;\n}\n\nfunction isWeakMap(a) {\n    return a instanceof WeakMap;\n}\n\nconst {HTMLElement: HTMLElement$1, customElements: customElements, Proxy: Proxy$1} = window;\n\nif (!isfunction(HTMLElement$1) || !isfunction(Proxy$1) || !isobject(customElements)) {\n    console.error(\"Proxy,HTMLElement ,customElements ,browser not supported !\");\n    throw new TypeError;\n}\n\nfunction isObject(value) {\n    var type = typeof value;\n    return value != null && (type == \"object\" || type == \"function\");\n}\n\nvar isObject_1 = isObject;\n\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\n\nvar freeGlobal = typeof commonjsGlobal == \"object\" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\nvar _freeGlobal = freeGlobal;\n\nvar freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n\nvar root = _freeGlobal || freeSelf || Function(\"return this\")();\n\nvar _root = root;\n\nvar now = function() {\n    return _root.Date.now();\n};\n\nvar now_1 = now;\n\nvar Symbol$1 = _root.Symbol;\n\nvar _Symbol = Symbol$1;\n\nvar objectProto = Object.prototype;\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\nvar nativeObjectToString = objectProto.toString;\n\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\nfunction getRawTag(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n    try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n    } catch (e) {}\n    var result = nativeObjectToString.call(value);\n    if (unmasked) {\n        if (isOwn) {\n            value[symToStringTag] = tag;\n        } else {\n            delete value[symToStringTag];\n        }\n    }\n    return result;\n}\n\nvar _getRawTag = getRawTag;\n\nvar objectProto$1 = Object.prototype;\n\nvar nativeObjectToString$1 = objectProto$1.toString;\n\nfunction objectToString(value) {\n    return nativeObjectToString$1.call(value);\n}\n\nvar _objectToString = objectToString;\n\nvar nullTag = \"[object Null]\", undefinedTag = \"[object Undefined]\";\n\nvar symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n\nfunction baseGetTag(value) {\n    if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n    }\n    return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);\n}\n\nvar _baseGetTag = baseGetTag;\n\nfunction isObjectLike(value) {\n    return value != null && typeof value == \"object\";\n}\n\nvar isObjectLike_1 = isObjectLike;\n\nvar symbolTag = \"[object Symbol]\";\n\nfunction isSymbol(value) {\n    return typeof value == \"symbol\" || isObjectLike_1(value) && _baseGetTag(value) == symbolTag;\n}\n\nvar isSymbol_1 = isSymbol;\n\nvar NAN = 0 / 0;\n\nvar reTrim = /^\\s+|\\s+$/g;\n\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\nvar reIsBinary = /^0b[01]+$/i;\n\nvar reIsOctal = /^0o[0-7]+$/i;\n\nvar freeParseInt = parseInt;\n\nfunction toNumber(value) {\n    if (typeof value == \"number\") {\n        return value;\n    }\n    if (isSymbol_1(value)) {\n        return NAN;\n    }\n    if (isObject_1(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject_1(other) ? other + \"\" : other;\n    }\n    if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n    }\n    value = value.replace(reTrim, \"\");\n    var isBinary = reIsBinary.test(value);\n    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\n\nvar toNumber_1 = toNumber;\n\nvar FUNC_ERROR_TEXT = \"Expected a function\";\n\nvar nativeMax = Math.max, nativeMin = Math.min;\n\nfunction debounce(func, wait, options) {\n    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n    if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    wait = toNumber_1(wait) || 0;\n    if (isObject_1(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = setTimeout(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n    }\n    function timerExpired() {\n        var time = now_1();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) {\n            clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(now_1());\n    }\n    function debounced() {\n        var time = now_1(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                clearTimeout(timerId);\n                timerId = setTimeout(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n}\n\nvar debounce_1 = debounce;\n\nconst cached_create_componet = new WeakMap;\n\nconst cached_callback_debounced_watchs = new WeakMap;\n\nfunction clearMounted() {\n    mountedctx.clear();\n}\n\nfunction clearUnMounted() {\n    unmountedctx.clear();\n}\n\nfunction checkctxandcallbck(callback) {\n    if (isfunction(callback)) {\n        if (ctxopen) ; else {\n            console.error(errormessage);\n            throw Error();\n        }\n    } else {\n        console.error(callback);\n        console.error(invalid_Function);\n        throw TypeError();\n    }\n}\n\nfunction createlifecyclecontext() {\n    let callbackset = new Set;\n    const getall = () => [ ...callbackset ];\n    const clear = () => {\n        callbackset = new Set;\n    };\n    const add = fun => {\n        checkctxandcallbck(fun);\n        callbackset.add(fun);\n    };\n    return {\n        add: add,\n        getall: getall,\n        clear: clear\n    };\n}\n\nfunction clearupdated() {\n    updatedctx.clear();\n}\n\nfunction clearcreated() {\n    createdctx.clear();\n}\n\nlet StateSet = new Set;\n\nlet watchrecord = [];\n\nfunction getwatchrecords() {\n    return [ ...watchrecord ];\n}\n\nfunction clearwatch() {\n    watchrecord = [];\n}\n\nconst invalid_Function = \"invalid Function\";\n\nconst errormessage = \"invalid useMounted or useUnMounted out of createComponent\";\n\nlet ctxopen = false;\n\nfunction getstates() {\n    return [ ...StateSet ];\n}\n\nfunction clearstate() {\n    StateSet = new Set;\n}\n\nfunction openctx() {\n    ctxopen = true;\n    clearall();\n}\n\nfunction closectx() {\n    ctxopen = false;\n    clearall();\n}\n\nfunction clearall() {\n    clearcreated();\n    clearupdated();\n    clearMounted();\n    clearUnMounted();\n    clearstate();\n    clearwatch();\n}\n\nconst mountedctx = createlifecyclecontext();\n\nconst unmountedctx = createlifecyclecontext();\n\nconst updatedctx = createlifecyclecontext();\n\nconst createdctx = createlifecyclecontext();\n\nfunction usewatch(state, callback) {\n    if (ctxopen) {\n        watchrecord.push([ state, callback ]);\n    }\n}\n\nclass ObserverTarget {\n    constructor() {\n        this.Listeners = new Set;\n    }\n    addListener(listener) {\n        const listenerset = this.Listeners;\n        listenerset.add(listener);\n    }\n    dispatch() {\n        const listenerset = this.Listeners;\n        listenerset.forEach(listener => {\n            Promise.resolve().then(() => {\n                listener();\n            });\n        });\n    }\n    removeListener(listener) {\n        const listenerset = this.Listeners;\n        listenerset.delete(listener);\n    }\n}\n\nconst {apply: apply, construct: construct, defineProperty: defineProperty, deleteProperty: deleteProperty, getOwnPropertyDescriptor: getOwnPropertyDescriptor, getPrototypeOf: getPrototypeOf, has: has, ownKeys: ownKeys, preventExtensions: preventExtensions} = Reflect;\n\nfunction get(target, propertyKey) {\n    if (isMap(target) || isWeakMap(target)) {\n        return target.get(propertyKey);\n    } else {\n        return Reflect.get(target, propertyKey);\n    }\n}\n\nfunction set(target, propertyKey, value) {\n    if (isMap(target) || isWeakMap(target)) {\n        target.set(propertyKey, value);\n        return true;\n    } else {\n        return Reflect.set(target, propertyKey, value);\n    }\n}\n\nfunction useststerecord(state) {\n    if (ctxopen) {\n        StateSet.add(state);\n    }\n}\n\nvar _a, _b, _c;\n\nconst addonelistner = Symbol(\"addonelistner\");\n\nconst removeonelistner = Symbol(\"removeonelistner\");\n\nconst cancelsubscribe = Symbol(\"cancelsubscribe\");\n\nconst debouncedispatch = Symbol(\"debouncedispatch\");\n\nconst invalid_primitive_or_object_state = \"invalid primitive or object state\";\n\nfunction isReactiveState(a) {\n    return a instanceof ReactiveState && a[Symbol.toStringTag] === \"ReactiveState\";\n}\n\nconst Targetsymbol = Symbol(\"eventtatget\");\n\nconst memlisteners = Symbol(\"memlisteners\");\n\nconst dispatchsymbol = Symbol(\"dispatch\");\n\nconst subscribesymbol = Symbol(\"subscribe\");\n\nconst removeallistenerssymbol = Symbol(\"removeallisteners\");\n\nconst addallistenerssymbol = Symbol(\"addallisteners\");\n\nclass ReactiveState {\n    constructor(init) {\n        this[Symbol.toStringTag] = \"ReactiveState\";\n        this[_a] = (() => {\n            const debouncedfun = debounce_1(() => {\n                this[Targetsymbol].dispatch();\n            });\n            return () => {\n                debouncedfun();\n            };\n        })();\n        this[_b] = new ObserverTarget;\n        this[_c] = new Set;\n        this.valueOf = () => this.value;\n        this.value = init;\n        defineProperty(this, \"value\", {\n            value: init,\n            configurable: true,\n            writable: true\n        });\n        useststerecord(this);\n    }\n    [(_a = debouncedispatch, removeallistenerssymbol)]() {\n        this[memlisteners].forEach(callback => {\n            this[removeonelistner](callback);\n        });\n    }\n    [removeonelistner](callback) {\n        this[Targetsymbol].removeListener(callback);\n    }\n    [addonelistner](callback) {\n        this[Targetsymbol].addListener(callback);\n    }\n    [addallistenerssymbol]() {\n        this[memlisteners].forEach(callback => {\n            this[addonelistner](callback);\n        });\n    }\n    toString() {\n        const value = this.valueOf();\n        return isprimitive(value) ? String(value) : isSet(value) ? JSON.stringify([ ...value ]) : isobject(value) ? JSON.stringify(value) : \"\";\n    }\n    [(_b = Targetsymbol, _c = memlisteners, dispatchsymbol)]() {\n        this[debouncedispatch]();\n    }\n    [subscribesymbol](eventlistener) {\n        this[memlisteners].add(eventlistener);\n        this[addonelistner](eventlistener);\n    }\n    [cancelsubscribe](eventlistener) {\n        if (eventlistener) {\n            this[memlisteners].delete(eventlistener);\n            this[removeonelistner](eventlistener);\n        }\n    }\n    [Symbol.toPrimitive]() {\n        const value = this.valueOf();\n        return isprimitive(value) ? value : isobject(value) ? JSON.stringify(value) : void 0;\n    }\n}\n\nfunction toArray(a) {\n    return (isarray(a) ? a : [ a ]).flat(1 / 0).filter(a => !isundefined(a));\n}\n\nfunction watch(state, callback) {\n    if (isarray(state) || isReactiveState(state)) {\n        const statearray = toArray(state);\n        if (!statearray.length) {\n            console.error(\"Empty array not allowed\");\n            throw new Error;\n        }\n        const debouncedcallback = debounce_1(callback);\n        const stateandlisteners = statearray.map(state1 => {\n            const listener = (() => {\n                const cachedfun = cached_callback_debounced_watchs.get(callback);\n                if (cachedfun) {\n                    return cachedfun;\n                } else {\n                    const listenfun = () => {\n                        debouncedcallback(...statearray.map(r => r.valueOf()));\n                    };\n                    cached_callback_debounced_watchs.set(callback, listenfun);\n                    return listenfun;\n                }\n            })();\n            watchsingle(state1, listener);\n            return [ state1, listener ];\n        });\n        const cancelWatch = () => {\n            stateandlisteners.forEach(([state, listener]) => {\n                state[cancelsubscribe](listener);\n            });\n        };\n        return cancelWatch;\n    } else {\n        console.error(state);\n        console.error(callback);\n        console.error(invalid_ReactiveState + invalid_Function);\n        throw new TypeError;\n    }\n}\n\nfunction watchsingle(state, callback) {\n    if (!(isReactiveState(state) && isfunction(callback))) {\n        console.error(state);\n        console.error(callback);\n        console.error(invalid_ReactiveState + invalid_Function);\n        throw TypeError();\n    }\n    state[subscribesymbol](callback);\n    requestAnimationFrame(() => {\n        rewatch(state);\n    });\n    usewatch(state, callback);\n}\n\nfunction unwatch(state) {\n    state[removeallistenerssymbol]();\n}\n\nfunction rewatch(state) {\n    state[addallistenerssymbol]();\n}\n\nconst t = [ \"input\", \"textarea\", \"option\", \"select\" ];\n\nvar e = (e, r, n) => \"value\" === r && t.includes(e) && \"button\" !== n || \"selected\" === r && \"option\" === e || \"checked\" === r && \"input\" === e || \"muted\" === r && \"video\" === e;\n\nconst r = /\\B([A-Z])/g, n = t => t.replace(r, \"-$1\").toLowerCase(), o = window.String, i = window.Reflect, {get: u, set: c, ownKeys: s} = i, f = \"value\";\n\nfunction a(t) {\n    return \"object\" == typeof t && null !== t;\n}\n\nfunction l(t) {\n    return \"string\" == typeof t;\n}\n\nfunction p(t) {\n    return t instanceof Set;\n}\n\nconst y = t => \"input\" === d(t) && (\"checkbox\" === u(t, \"type\") || \"radio\" === u(t, \"type\"));\n\nfunction d(t) {\n    return t.tagName.toLowerCase();\n}\n\nfunction w(t, e, r) {\n    return t.setAttribute(e, r);\n}\n\nfunction g(t, e) {\n    return t.removeAttribute(e);\n}\n\nfunction createeleattragentreadwrite(t) {\n    !function(t) {\n        if (!(t instanceof Element)) throw TypeError();\n    }(t);\n    var r = Object.create(null);\n    const i = new Proxy(r, {\n        ownKeys() {\n            const e = function(t) {\n                const e = d(t);\n                return \"textarea\" === e || \"select\" === e || \"input\" === e && \"text\" === u(t, \"type\");\n            }(t), r = function(t) {\n                return t.getAttributeNames();\n            }(t);\n            return Array.from(new Set([ ...r, y(t) ? \"checked\" : void 0, e ? f : void 0 ].flat(1 / 0).filter(t => !!t)));\n        },\n        get(r, n) {\n            if (e(d(t), o(n), u(t, \"type\"))) return u(t, o(n));\n            {\n                const e = function(t, e) {\n                    return t.getAttribute(e);\n                }(t, o(n));\n                if (\"\" === e) return !0;\n                if (null === e) return;\n                if (!l(e)) return;\n                try {\n                    return JSON.parse(o(e));\n                } catch (t) {\n                    return e;\n                }\n            }\n        },\n        set(r, i, s) {\n            if (\"function\" == typeof s) throw TypeError();\n            if (e(d(t), o(i), u(t, \"type\"))) return c(t, o(i), s);\n            if (\"style\" === i) {\n                const e = l(s) ? s : a(s) ? (y = s, y = JSON.parse(JSON.stringify(y)), Object.entries(y).map(([t, e]) => [ n(t).trim(), e ]).map(([t, e]) => t + \":\" + e).join(\";\")) : o(s);\n                return c(u(t, \"style\"), \"cssText\", e.trim()), !0;\n            }\n            if (\"class\" === i && a(s)) {\n                const e = (f = s, Array.isArray(f) ? s.join(\" \") : p(s) ? [ ...s ].join(\" \") : o(s));\n                return w(t, o(i), e), !0;\n            }\n            return !1 === s || null == s ? (g(t, o(i)), !0) : p(s) ? (w(t, o(i), JSON.stringify([ ...s ])), \n            !0) : (!0 === s && (s = \"\"), w(t, o(i), a(s) ? JSON.stringify(s) : o(s)), !0);\n            var f, y;\n        },\n        deleteProperty: (e, r) => (g(t, o(r)), !0),\n        has: (t, e) => s(i).includes(e),\n        defineProperty: () => !1,\n        getOwnPropertyDescriptor(t, e) {\n            const r = {\n                enumerable: !0,\n                configurable: !0,\n                writable: !0\n            }, n = u(i, e);\n            return void 0 !== n ? {\n                value: n,\n                ...r\n            } : void 0;\n        },\n        setPrototypeOf: () => !1\n    });\n    return i;\n}\n\nconst rootnode = document.body;\n\nconst connectedeventname = Symbol(\"mounted\").toString();\n\nconst disconnectedeventname = Symbol(\"unmounted\").toString();\n\nconst callback = function(mutations) {\n    mutations.forEach((function(record) {\n        console.log(\"Mutation: \", record);\n        const addedNodes = [ ...record.addedNodes ];\n        addedNodes.forEach(e => {\n            if (e instanceof Element) {\n                const subnodes = [ ...e.querySelectorAll(\"*\"), e ];\n                subnodes.forEach(n => {\n                    dispatchconnected(n);\n                });\n            }\n        });\n        const removedNodes = [ ...record.removedNodes ];\n        removedNodes.forEach(e => {\n            if (e instanceof Element) {\n                const subnodes = [ ...e.querySelectorAll(\"*\"), e ];\n                subnodes.forEach(n => {\n                    dispatchdisconnected(n);\n                });\n            }\n        });\n    }));\n};\n\nfunction dispatchconnected(e) {\n    e.dispatchEvent(new Event(connectedeventname));\n}\n\nfunction dispatchdisconnected(e) {\n    e.dispatchEvent(new Event(disconnectedeventname));\n}\n\nconst mo = new MutationObserver(callback);\n\nconst option = {\n    childList: true,\n    subtree: true\n};\n\nmo.observe(rootnode, option);\n\nconst updatedeventname = Symbol(\"updated\").toString();\n\nnew MutationObserver(mutations => {\n    mutations.forEach((function(record) {\n        console.log(\"Mutation: \", record);\n        const target = record.target;\n        dispatchupdated(target);\n    }));\n}).observe(rootnode, {\n    subtree: true,\n    attributes: true,\n    childList: true,\n    characterData: true\n});\n\nfunction dispatchupdated(e) {\n    e.dispatchEvent(new Event(updatedeventname, {\n        bubbles: true\n    }));\n}\n\nconst createdeventname = Symbol(\"created\").toString();\n\nfunction dispatchcreated(e) {\n    e.dispatchEvent(new Event(createdeventname));\n}\n\nfunction addmountedlistner(ele, call) {\n    ele.addEventListener(connectedeventname, call);\n}\n\nfunction addcreatedlistner(ele, call) {\n    ele.addEventListener(createdeventname, call, {\n        once: true\n    });\n}\n\nfunction addupdatedlistner(ele, call) {\n    ele.addEventListener(updatedeventname, call);\n}\n\nfunction addstopupdatelistener(ele) {\n    ele.addEventListener(updatedeventname, e => {\n        if (e.target !== ele && ele.tagName.includes(\"-\")) {\n            e.stopPropagation();\n        }\n    });\n}\n\nfunction addunmountedlistner(ele, call) {\n    ele.addEventListener(disconnectedeventname, call);\n}\n\nfunction merge_entries(a) {\n    const m = {};\n    a.forEach(([key, value]) => {\n        if (!m[key]) {\n            m[key] = new Set;\n        }\n        value.forEach(v => {\n            m[key].add(v);\n        });\n    });\n    return Object.entries(m).map(([k, v]) => [ k, [ ...v ] ]);\n}\n\nconst VirtualElementSet = new WeakSet;\n\nconst Letter_case_and_Chinese = /[A-Za-z\\u4e00-\\u9fa5]/;\n\nfunction isVirtualdom(a) {\n    return VirtualElementSet.has(a);\n}\n\nfunction createVirtualElement(type, props = {}, children = []) {\n    props = Object.assign({}, props);\n    children = children.flat(1 / 0);\n    const propsentries = Object.entries(props);\n    const propsentriesNOTevents = propsentries.filter(([key]) => !(key.startsWith(\"@\") || key.startsWith(\"on\")));\n    const Entries_beginning_with_a_letter = propsentriesNOTevents.filter(([key]) => Letter_case_and_Chinese.test(key[0]));\n    const virtual = Object.create(null);\n    const vdom = virtual;\n    [ \"onevent\", \"element\", \"type\", \"props\", \"children\", \"directives\", \"bindattr\" ].forEach(key => {\n        defineProperty(virtual, key, {\n            writable: true\n        });\n    });\n    vdom.element = [];\n    Object.assign(virtual, {\n        type: type,\n        bindattr: Object.fromEntries(Entries_beginning_with_a_letter.filter(e => isReactiveState(e[1]))),\n        props: Object.fromEntries(Entries_beginning_with_a_letter.filter(e => !isReactiveState(e[1])).map(([key, value]) => [ key, isstring(value) ? value.trim() : value ])),\n        children: children,\n        onevent: Object.fromEntries(merge_entries([ ...propsentries.filter(([key]) => \"@\" == key[0]).map(([key, value]) => [ key.slice(1).toLowerCase().trim(), [ value ].flat(1 / 0) ]), ...propsentries.filter(([key]) => key.startsWith(\"on\")).map(([key, value]) => [ key.slice(2).toLowerCase().trim(), [ value ].flat(1 / 0) ]) ])),\n        directives: Object.fromEntries(propsentriesNOTevents.filter(([key]) => key[0] === \"*\" || key[0] === \"$\").map(([key, value]) => [ key.slice(1).toLowerCase().trim(), value ]))\n    });\n    defineProperty(virtual, Symbol.toStringTag, {\n        value: \"VirtualElement\"\n    });\n    preventExtensions(virtual);\n    VirtualElementSet.add(virtual);\n    Object.freeze(vdom);\n    return virtual;\n}\n\nfunction isvalidvdom(v) {\n    if (isstring(v)) {\n        return true;\n    }\n    if (isnumber(v)) {\n        return true;\n    }\n    let flag = false;\n    if (isarray(v)) {\n        return v.every(e => isvalidvdom(e));\n    } else if (isVirtualdom(v)) {\n        return isvalidvdom(v.children);\n    } else if (isReactiveState(v)) {\n        return true;\n    }\n    return flag;\n}\n\nfunction isclassextendsHTMLElement(initclass) {\n    return !!(isfunction(initclass) && initclass.prototype && initclass.prototype instanceof HTMLElement);\n}\n\nfunction getUnMounted() {\n    return unmountedctx.getall();\n}\n\nfunction getMounted() {\n    return mountedctx.getall();\n}\n\nfunction seteletext(e, v) {\n    e.textContent = v;\n}\n\nfunction setelehtml(e, v) {\n    e.innerHTML = v;\n}\n\nfunction appendchild(container, ele) {\n    container.appendChild(ele);\n}\n\nfunction createsvgelement() {\n    return createElementNS(svgnamespace, \"svg\");\n}\n\nfunction createDocumentFragment() {\n    return document.createDocumentFragment();\n}\n\nfunction createnativeelement(type) {\n    return document.createElement(type);\n}\n\nfunction createElementNS(namespace, name) {\n    return document.createElementNS(namespace, name);\n}\n\nfunction createtextnode(data) {\n    return document.createTextNode(String(data));\n}\n\nconst svgnamespace = \"http://www.w3.org/2000/svg\";\n\nfunction changetext(textnode, value) {\n    textnode.nodeValue = String(value);\n}\n\nconst mathnamespace = \"http://www.w3.org/1998/Math/MathML\";\n\nfunction createmathelement() {\n    return createElementNS(mathnamespace, \"math\");\n}\n\nfunction removeNode(node) {\n    let parentNode = node.parentNode;\n    if (parentNode) {\n        parentNode.removeChild(node);\n    }\n}\n\nfunction replaceChild(newChild, oldChild) {\n    let parentNode = oldChild.parentNode;\n    if (parentNode) {\n        parentNode.replaceChild(newChild, oldChild);\n    }\n}\n\nfunction domaddlisten(ele, event, call) {\n    ele.addEventListener(event, call);\n}\n\nfunction domremovelisten(ele, event, call) {\n    ele.removeEventListener(event, call);\n}\n\nfunction getchildNodes(ele) {\n    return [ ...ele.childNodes ];\n}\n\nfunction createanotherhtmldocument() {\n    return document.implementation.createHTMLDocument(\"\");\n}\n\nfunction querySelectorAll(selector) {\n    return [ ...document.querySelectorAll(selector) ];\n}\n\nfunction mountrealelement(ele, container, clear = true) {\n    if (clear) {\n        seteletext(container, \"\");\n    }\n    const eles = toArray(ele).flat(Infinity);\n    eles.forEach(e => appendchild(container, e));\n    return container;\n}\n\nconst componentsymbol = Symbol(\"component\");\n\nfunction iscomponent(a) {\n    return isfunction(a) && get(a, componentsymbol) === componentsymbol;\n}\n\nconst charactorlist = Array(26).fill(undefined).map((v, i) => 97 + i).map(n => String.fromCharCode(n));\n\nconst hexnumberlist = Array(16).fill(undefined).map((v, i) => i).map(a => a.toString(16));\n\nconst charactorandnumberlist = [ ...new Set([ ...hexnumberlist, ...charactorlist ]) ];\n\nfunction getrandomcharactor() {\n    return get(charactorlist, Math.floor(Math.random() * charactorlist.length));\n}\n\nfunction getrandomhexnumberandcharactor() {\n    return get(charactorandnumberlist, Math.floor(Math.random() * charactorandnumberlist.length));\n}\n\nfunction getrandomstringandnumber(length = 1) {\n    return Array(length).fill(undefined).map(() => getrandomcharactor()).join(\"\") + \"-\" + Array(length).fill(undefined).map(() => getrandomhexnumberandcharactor()).join(\"\");\n}\n\nconst invalid_custom_element_class = \"invalid custom element class !\";\n\nif (!isobject(window.customElements)) {\n    console.error(\" customElements  not supported !\");\n    throw new TypeError;\n}\n\nfunction Usevaluetoquerythekeyfromthetable(table, Componentstatusname) {\n    const outputentrie = Object.entries(table).find(v => v[1] === Componentstatusname);\n    return outputentrie ? outputentrie[0] : undefined;\n}\n\nwindow.CustomElementRegistry = get(getPrototypeOf(window.customElements), \"constructor\");\n\nconst elementset = Symbol.for(\"elementset\");\n\nconst elementmap = Symbol.for(\"elementmap\");\n\nconst {CustomElementRegistry: CustomElementRegistry} = window;\n\nconst customElements$1 = window.customElements;\n\nif (!has(customElements$1, elementset)) {\n    Reflect.set(customElements$1, elementset, new Set);\n}\n\nif (!has(customElements$1, elementmap)) {\n    Reflect.set(customElements$1, elementmap, {});\n}\n\nvar RandomDefineCustomElement = (initclass, extendsname) => RandomDefineCustomElement$1(initclass, extendsname);\n\nfunction RandomDefineCustomElement$1(initclass, extendsname, length = 1) {\n    if (!isclassextendsHTMLElement(initclass)) {\n        console.error(initclass);\n        console.error(invalid_custom_element_class);\n        throw TypeError();\n    }\n    if (!get(customElements$1, elementset).has(initclass)) {\n        const elementname = getrandomstringandnumber(length);\n        if (customElements$1.get(elementname)) {\n            return RandomDefineCustomElement$1(initclass, extendsname, length + 1);\n        } else {\n            if (extendsname) {\n                customElements$1.define(elementname, initclass, {\n                    extends: extendsname\n                });\n            } else {\n                customElements$1.define(elementname, initclass);\n            }\n        }\n        return elementname;\n    } else {\n        return Usevaluetoquerythekeyfromthetable(get(customElements$1, elementmap), initclass);\n    }\n}\n\ncustomElements$1.define = function(name, constructor, options) {\n    if (!isclassextendsHTMLElement(constructor)) {\n        console.error(constructor);\n        console.error(invalid_custom_element_class);\n        throw TypeError();\n    }\n    if (!get(customElements$1, elementset).has(constructor)) {\n        if (has(customElements$1[elementmap], name)) {\n            RandomDefineCustomElement$1(constructor, options ? options.extends : undefined);\n        } else {\n            CustomElementRegistry.prototype.define.call(customElements$1, name, constructor, options);\n            customElements$1[elementset].add(constructor);\n            customElements$1[elementmap][name] = constructor;\n        }\n    }\n};\n\nset(customElements$1, Symbol.iterator, () => {\n    const entries = Object.entries(customElements$1[elementmap]);\n    return entries[Symbol.iterator].call(entries);\n});\n\nfunction createcostumelemet(initclass, propsjson, children) {\n    let type = initclass;\n    if (isfunction(type)) {\n        type = autocreateclass(type);\n    }\n    initclass = type;\n    if (isclassextendsHTMLElement(initclass)) {\n        RandomDefineCustomElement(initclass);\n        return construct(initclass, [ propsjson, children ]);\n    } else {\n        console.error(initclass);\n        console.error(invalid_custom_element_class);\n        throw TypeError();\n    }\n}\n\nfunction isconnected(element) {\n    const isConnectedstate = element.isConnected;\n    if (isboolean(isConnectedstate)) {\n        return isConnectedstate;\n    } else {\n        return document.documentElement === getancestornode(element);\n    }\n}\n\nfunction getancestornode(node) {\n    while (node && node.parentNode && node.parentNode !== document) {\n        node = node.parentNode;\n    }\n    return node;\n}\n\nconst directive = {};\n\nconst applydirects = function(element, vdom) {\n    Object.entries(vdom.directives).forEach(([name, value]) => {\n        const direfun = directive[name];\n        if (isfunction(direfun)) {\n            direfun(value, element, vdom, call => {\n                addmountedlistner(element, call);\n            }, call => {\n                addunmountedlistner(element, call);\n            }, call => {\n                addupdatedlistner(element, call);\n            });\n        } else {\n            console.error(vdom.directives);\n            console.error(\"invalid directives \" + name);\n            throw new TypeError;\n        }\n    });\n};\n\nconst eventlistenerssymbol = Symbol(\"eventlisteners\");\n\nfunction onevent(element, eventname, callback) {\n    firstaddlisteners(element, eventname, toArray(callback));\n}\n\nfunction firstaddlisteners(ele, event, callarray) {\n    const element = ele;\n    callarray.forEach(call => {\n        if (!isfunction(call)) {\n            console.error(call);\n            console.error(invalid_Function);\n            throw TypeError();\n        }\n        if (!has(element, eventlistenerssymbol)) {\n            set(element, eventlistenerssymbol, []);\n        }\n        get(ele, eventlistenerssymbol).push([ event, call ]);\n        domaddlisten(ele, event, call);\n    });\n}\n\nfunction removelisteners(ele) {\n    if (has(ele, eventlistenerssymbol)) {\n        get(ele, eventlistenerssymbol).forEach(([event, call]) => {\n            domremovelisten(ele, event, call);\n        });\n    }\n}\n\nfunction readdlisteners(ele) {\n    if (has(ele, eventlistenerssymbol)) {\n        get(ele, eventlistenerssymbol).forEach(([event, call]) => {\n            domaddlisten(ele, event, call);\n        });\n    }\n}\n\nfunction handleprops(element, vdom) {\n    vdom.element.push(element);\n    const attribute1 = createeleattragentreadwrite(element);\n    Object.assign(attribute1, vdom.props);\n    addmountedlistner(element, () => {\n        const cacelarr = Object.entries(vdom.bindattr).map(([key, primitivestate]) => {\n            attribute1[key] = primitivestate.valueOf();\n            return watch(primitivestate, () => {\n                const state = primitivestate;\n                if (isconnected(element)) {\n                    attribute1[key] = state.valueOf();\n                }\n            });\n        });\n        addunmountedlistner(element, () => {\n            cacelarr.forEach(f => {\n                f();\n            });\n        });\n    });\n    Object.entries(vdom.onevent).forEach(([event, callbacks]) => {\n        onevent(element, event, callbacks);\n    });\n    [ ...Object.values(vdom.bindattr), ...Object.values(vdom.directives) ].flat(1 / 0).filter(e => isReactiveState(e)).forEach(e => {\n        if (!has(element, bindstatesymbol)) {\n            set(element, bindstatesymbol, new Set);\n        }\n        get(element, bindstatesymbol).add(e);\n    });\n}\n\nconst bindstatesymbol = Symbol(\"bindstate\");\n\nfunction throwinvalideletype(type) {\n    console.error(type);\n    console.error(\"invalid element type!\");\n    console.error(invalid_Virtualdom);\n    throw TypeError();\n}\n\nfunction render(vdom, namespace) {\n    if (isarray(vdom)) {\n        return vdom.map(a => render(a)).flat(1 / 0);\n    }\n    if (isnumber(vdom) || isstring(vdom)) {\n        const textnode = createtextnode(vdom);\n        return textnode;\n    } else if (isReactiveState(vdom)) {\n        const reactive = vdom;\n        const textnode = createtextnode(String(reactive));\n        watch(reactive, () => {\n            const state = reactive;\n            if (isconnected(element)) {\n                changetext(textnode, String(state));\n            }\n        });\n        const element = textnode;\n        set(element, bindstatesymbol, new Set);\n        get(element, bindstatesymbol).add(reactive);\n        return textnode;\n    } else if (isVirtualdom(vdom)) {\n        let {type: type} = vdom;\n        if (isfunction(type)) {\n            type = autocreateclass(type);\n        }\n        let element = undefined;\n        if (typeof type === \"string\") {\n            if (type === \"script\") {\n                return createElementNS(\"never\", \"script\");\n            } else if (type === \"svg\") {\n                element = createsvgelement();\n            } else if (type === \"math\") {\n                element = createmathelement();\n            } else if (\"\" === type) {\n                const fragmentnode = createDocumentFragment();\n                mountrealelement(render(vdom.children), fragmentnode);\n                return fragmentnode;\n            } else if (type === \"html\") {\n                const fragmentnode = createElementNS(\"never\", \"html\");\n                mountrealelement(render(vdom.children), fragmentnode);\n                return fragmentnode;\n            } else {\n                element = namespace ? createElementNS(namespace, type) : createnativeelement(type);\n            }\n        } else if (typeof type == \"function\") {\n            if (isobject(type[\"defaultProps\"])) {\n                Object.assign(vdom.props, JSON.parse(JSON.stringify({\n                    ...type[\"defaultProps\"],\n                    ...vdom.props\n                })));\n            }\n            const propsjson = JSON.parse(JSON.stringify({\n                ...vdom.props,\n                ...Object.fromEntries(Object.entries(vdom.bindattr).map(([key, value]) => [ key, value.value ]))\n            }));\n            element = createcostumelemet(type, propsjson, vdom.children);\n        } else {\n            throwinvalideletype(vdom);\n        }\n        dispatchcreated(element);\n        applydirects(element, vdom);\n        if (type && (isfunction(type) || isstring(type))) {\n            if (!iscomponent(type)) {\n                if (element) {\n                    mountrealelement(vdom.children.map(e => {\n                        if (type === \"svg\" && isVirtualdom(e)) {\n                            return render(e, svgnamespace);\n                        } else if (type === \"math\" && isVirtualdom(e)) {\n                            return render(e, mathnamespace);\n                        } else if (namespace && isVirtualdom(e)) {\n                            return render(e, namespace);\n                        } else {\n                            return render(e);\n                        }\n                    }), element);\n                }\n            }\n        }\n        if (element) {\n            handleprops(element, vdom);\n        }\n        return element;\n    } else {\n        throwinvalideletype(vdom);\n    }\n}\n\nfunction isNodeArray(arr) {\n    return !!(isarray(arr) && arr.length && arr.every(a => isNode(a)));\n}\n\nfunction isNode(a) {\n    return a instanceof Node;\n}\n\nconst invalid_Virtualdom = \"invalid Virtualdom \";\n\nfunction MountElement(vdom, container) {\n    if (isarray(vdom)) {\n        vdom = vdom.flat(Infinity);\n        if (!vdom.length) {\n            console.error(\"Empty array not allowed\");\n            throw new TypeError;\n        }\n    }\n    const el = container;\n    if (!(el instanceof HTMLElement)) {\n        console.error(el);\n        console.error(\"invalid container HTMLElement!\");\n        throw TypeError();\n    }\n    if (el === document.body || el === document.documentElement || el === document.head) {\n        console.error(el);\n        console.error(\"Do not mount  to <html> or <body> <head>.\");\n        throw Error();\n    }\n    const elesarray = toArray(vdom);\n    if (isvalidvdom(vdom)) {\n        mountrealelement(render(elesarray), container);\n    } else if (isNode(vdom) || isNodeArray(vdom)) {\n        mountrealelement(elesarray, container);\n    } else {\n        console.error(vdom);\n        console.error(invalid_Virtualdom);\n        throw TypeError();\n    }\n    return container;\n}\n\nfunction readonlyproxy(target) {\n    return new Proxy(target, {\n        set() {\n            return true;\n        },\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        setPrototypeOf() {\n            return false;\n        }\n    });\n}\n\nconst componentsstylesheet = new Map;\n\nfunction createlinkstylesheet(url) {\n    return render(h(\"link\", {\n        href: url,\n        rel: \"stylesheet\"\n    }));\n}\n\nfunction isCSSStyleRule(a) {\n    return gettagtype(a) === \"CSSStyleRule\";\n}\n\nfunction isCSSMediaRule(a) {\n    return gettagtype(a) === \"CSSMediaRule\";\n}\n\nfunction isCSSImportRule(a) {\n    return gettagtype(a) === \"CSSImportRule\";\n}\n\nfunction cssrulestocsstext(cssrules) {\n    return cssrules.map(c => c.cssText).join(\"\\n\");\n}\n\nfunction prefixcssmediarule(cssrule, prefix) {\n    const rulesarr = prefixcssrules([ ...cssrule.cssRules ], prefix);\n    const conditionText = cssrule.conditionText;\n    const cssText = cssrule.cssText.slice(0, 7) + conditionText + \"{\" + cssrulestocsstext(rulesarr) + \"}\";\n    return {\n        cssText: cssText,\n        conditionText: conditionText,\n        cssRules: rulesarr,\n        [Symbol.toStringTag]: \"CSSMediaRule\"\n    };\n}\n\nfunction createcssBlob(source) {\n    const cachedBlob = sourcecssblobCache.get(source);\n    if (cachedBlob) {\n        return cachedBlob;\n    } else {\n        const bloburl = URL.createObjectURL(new Blob([ source ], {\n            type: \"text/css\"\n        }));\n        sourcecssblobCache.set(source, bloburl);\n        return bloburl;\n    }\n}\n\nconst sourcecssblobCache = new Map;\n\nfunction savestyleblob(tagname, csstext, urltext) {\n    tagname = tagname.toLowerCase();\n    const prefix = tagname;\n    if (!get(componentsstylesheet, prefix)) {\n        set(componentsstylesheet, tagname, new Set);\n    }\n    if (csstext) {\n        get(componentsstylesheet, prefix).add(createcssBlob(csstext));\n    } else if (urltext) {\n        get(componentsstylesheet, prefix).add(urltext);\n    }\n}\n\nfunction selectoraddprefix(cssstylerule, prefix) {\n    const selectorold = cssstylerule.selectorText;\n    const stylebodyold = cssstylerule.cssText.slice(selectorold.length);\n    const selectorTextss = selectorold;\n    const selectorarray = selectorTextss.split(\",\");\n    const selectoraftertransform = selectorarray.map(selectorTextone => {\n        let prefixselector = prefix + \" \" + selectorTextone;\n        if (selectorTextone.startsWith(\"*\")) {\n            prefixselector = prefixselector + \",\" + selectorTextone.replace(\"*\", prefix);\n        }\n        return prefixselector;\n    }).join(\",\");\n    return {\n        selectorText: selectoraftertransform,\n        cssText: selectoraftertransform + stylebodyold,\n        [Symbol.toStringTag]: \"CSSStyleRule\"\n    };\n}\n\nfunction prefixcssrules(cssRulesarray, prefix) {\n    return cssRulesarray.map(cssrule => {\n        if (isCSSStyleRule(cssrule)) {\n            const resultoutput = selectoraddprefix(cssrule, prefix);\n            return resultoutput;\n        } else if (isCSSMediaRule(cssrule)) {\n            return prefixcssmediarule(cssrule, prefix);\n        } else if (isCSSImportRule(cssrule)) {\n            savestyleblob(prefix, undefined, cssrule.href);\n            return;\n        } else {\n            return cssrule;\n        }\n    }).filter(Boolean);\n}\n\nfunction parsecsstext(text) {\n    const styleelement = render(h(\"style\", [ text ]));\n    const otherdocument = createanotherhtmldocument();\n    appendchild(otherdocument.documentElement, styleelement);\n    return Array.from(get(get(styleelement, \"sheet\"), \"cssRules\"));\n}\n\nfunction transformcsstext(text, prefix) {\n    const cachedtext = oldcsstotransformedcss.get(text);\n    if (cachedtext) {\n        return cachedtext;\n    } else {\n        const css = text;\n        const cssomold = parsecsstext(css);\n        const cssomnew = prefixcssrules(cssomold, prefix).filter(Boolean);\n        const cssnewtext = cssrulestocsstext(cssomnew);\n        oldcsstotransformedcss.set(text, cssnewtext);\n        return cssnewtext;\n    }\n}\n\nconst oldcsstotransformedcss = new Map;\n\nfunction registercssprefix(text, prefix) {\n    const css = text;\n    const cssnewtext = transformcsstext(css, prefix);\n    savestyleblob(prefix, cssnewtext);\n}\n\nfunction loadlinkstyle(stylelinkelement, container) {\n    return new Promise(rs => {\n        const loaderrorfun = () => {\n            stylelinkelement.onload = stylelinkelement.onerror = null;\n            rs();\n        };\n        stylelinkelement.onload = loaderrorfun;\n        stylelinkelement.onerror = loaderrorfun;\n        appendchild(container, stylelinkelement);\n    });\n}\n\nfunction waitloadallstyle(prefix, containerthis) {\n    return Promise.all([ ...get(componentsstylesheet, prefix) ].map(styleurl => {\n        if (querySelectorAll(`link[rel=\"stylesheet\"][href=\"${styleurl}\"]`).length) {\n            return Promise.resolve();\n        } else {\n            return loadlinkstyle(createlinkstylesheet(styleurl), containerthis);\n        }\n    }));\n}\n\nfunction setimmediate(fun) {\n    return Promise.resolve().then(() => fun());\n}\n\nfunction onmounted(ele) {\n    if (isarray(ele)) {\n        ele.forEach(e => {\n            onmounted(e);\n        });\n    } else if (isNode(ele)) {\n        readdlisteners(ele);\n        if (has(ele, bindstatesymbol)) {\n            get(ele, bindstatesymbol).forEach(state => {\n                rewatch(state);\n                state[dispatchsymbol]();\n            });\n        }\n        if (has(ele, innerstatesymbol)) {\n            get(ele, innerstatesymbol).forEach(state => {\n                rewatch(state);\n            });\n        }\n        if (has(ele, innerwatchrecords)) {\n            const watchrecords = get(ele, innerwatchrecords);\n            watchrecords.forEach(([state, eventlistener]) => {\n                if (eventlistener) {\n                    state[addonelistner](eventlistener);\n                }\n            });\n        }\n        onmounted(getchildNodes(ele));\n    }\n}\n\nfunction onunmounted(ele) {\n    if (isarray(ele)) {\n        ele.forEach(e => {\n            onunmounted(e);\n        });\n    } else if (isNode(ele)) {\n        removelisteners(ele);\n        if (has(ele, innerstatesymbol)) {\n            get(ele, innerstatesymbol).forEach(state => {\n                unwatch(state);\n            });\n        }\n        if (has(ele, innerwatchrecords)) {\n            const watchrecords = get(ele, innerwatchrecords);\n            watchrecords.forEach(([state, eventlistener]) => {\n                if (eventlistener) {\n                    state[removeonelistner](eventlistener);\n                }\n            });\n        }\n        onunmounted(getchildNodes(ele));\n    }\n}\n\nconst readysymbol = Symbol(\"readystate\");\n\nvar _a$1;\n\nconst attributeChangedCallback = Symbol(\"attributeChanged\");\n\nconst firstinstalledcallback = Symbol(\"firstinstalled\");\n\nfunction connectedCallback(componentelement) {\n    AttrChange.prototype.connectedCallback.call(componentelement);\n}\n\nfunction disconnectedCallback(componentelement) {\n    AttrChange.prototype.disconnectedCallback.call(componentelement);\n}\n\nclass AttrChange extends HTMLElement {\n    constructor() {\n        super();\n        this[_a$1] = false;\n        const defaultProps = get(this.constructor, \"defaultProps\");\n        const attrs = createeleattragentreadwrite(this);\n        if (isobject(defaultProps)) {\n            Object.assign(attrs, defaultProps);\n        }\n        new MutationObserver(mutations => {\n            mutations.forEach(mutation => {\n                if (mutation.type == \"attributes\") {\n                    console.log(\"The \" + mutation.attributeName + \" attribute was modified.\");\n                    const callback = get(this, attributeChangedCallback);\n                    let qualifiedName = mutation.attributeName;\n                    if (qualifiedName && isfunction(callback)) {\n                        callback.call(this, qualifiedName);\n                    }\n                }\n            });\n        }).observe(this, {\n            attributes: true\n        });\n    }\n    disconnectedCallback() {\n        setimmediate(() => {\n            onunmounted(this);\n        });\n    }\n    connectedCallback() {\n        setimmediate(() => {\n            if (!this[readysymbol]) {\n                this[readysymbol] = true;\n                const callback = get(this, firstinstalledcallback);\n                if (isfunction(callback)) {\n                    setimmediate(() => {\n                        callback.call(this);\n                    });\n                }\n            }\n            onmounted(this);\n        });\n    }\n}\n\n_a$1 = readysymbol;\n\nfunction getcreated() {\n    return createdctx.getall();\n}\n\nfunction getupdated() {\n    return updatedctx.getall();\n}\n\nconst waittranformcsssymbol = Symbol(\"waittranformcss\");\n\nconst innerwatchrecords = Symbol(\"innerwatchrecord\");\n\nconst innerstatesymbol = Symbol(\"innerstate\");\n\nconst attributessymbol = Symbol(\"attributes\");\n\nconst elementsymbol = Symbol(\"innerelement\");\n\nconst inner_vdom_symbol = Symbol(\"innervdom\");\n\nfunction createComponentold(custfun) {\n    var _a, _b, _c;\n    if (isfunction(custfun)) {\n        const cached_class = cached_create_componet.get(custfun);\n        if (cached_class) {\n            return cached_class;\n        }\n        const defaultProps = get(custfun, \"defaultProps\");\n        const css = get(custfun, \"css\");\n        class Component extends AttrChange {\n            constructor(propsjson = {}, children = []) {\n                super();\n                this[_a] = {};\n                this[_c] = false;\n                const css = get(this.constructor, \"css\");\n                if (css) {\n                    const prefix = this.tagName.toLowerCase();\n                    if (!get(componentsstylesheet, prefix)) {\n                        set(componentsstylesheet, prefix, new Set);\n                        this[waittranformcsssymbol] = () => setimmediate(() => {\n                            registercssprefix(css, prefix);\n                        });\n                    }\n                }\n                const attrs = createeleattragentreadwrite(this);\n                if (isobject(propsjson)) {\n                    Object.assign(attrs, propsjson);\n                }\n                const props = attrs;\n                openctx();\n                const thisattributess = Object.fromEntries(Object.entries(props).map(([key]) => [ key, (() => {\n                    const attributes = createeleattragentreadwrite(this);\n                    const state = new ReactiveState;\n                    defineProperty(state, \"value\", {\n                        get() {\n                            return get(attributes, key);\n                        },\n                        configurable: true\n                    });\n                    return state;\n                })() ]));\n                this[attributessymbol] = thisattributess;\n                const readonlyprop = readonlyproxy(Object.fromEntries(Object.entries(thisattributess).map(([key, value]) => [ key, readonlyproxy(value) ])));\n                let possiblyvirtualdom;\n                try {\n                    possiblyvirtualdom = apply(custfun, undefined, [ readonlyprop, children.flat(1 / 0) ]);\n                } catch (error) {\n                    closectx();\n                    console.error(\"error in component\");\n                    throw error;\n                }\n                possiblyvirtualdom = toArray(possiblyvirtualdom);\n                if (isvalidvdom(possiblyvirtualdom)) {\n                    const vdomarray = toArray(possiblyvirtualdom);\n                    this[inner_vdom_symbol] = vdomarray.flat(Infinity).filter(Boolean);\n                    const mountedcallbacks = getMounted();\n                    const unmountedcallbacks = getUnMounted();\n                    const createdcallbacks = getcreated();\n                    const updatedcallbacks = getupdated();\n                    this[innerstatesymbol] = getstates();\n                    this[innerwatchrecords] = getwatchrecords();\n                    closectx();\n                    mountedcallbacks.forEach(callback => {\n                        addmountedlistner(this, callback);\n                    });\n                    unmountedcallbacks.forEach(callback => {\n                        addunmountedlistner(this, callback);\n                    });\n                    createdcallbacks.forEach(callback => {\n                        addcreatedlistner(this, callback);\n                    });\n                    updatedcallbacks.forEach(callback => {\n                        addupdatedlistner(this, callback);\n                    });\n                    addstopupdatelistener(this);\n                } else {\n                    closectx();\n                    console.error(possiblyvirtualdom);\n                    console.error(invalid_Virtualdom);\n                    throw TypeError();\n                }\n            }\n            [(_a = attributessymbol, _b = componentsymbol, _c = readysymbol, firstinstalledcallback)]() {\n                const thencallbackfirst = () => {\n                    seteletext(this, \"\");\n                    return waitloadallstyle(prefix, document.head);\n                };\n                const thencallbacksecond = () => {\n                    mountrealelement(this[elementsymbol], this, false);\n                    this[waittranformcsssymbol] = undefined;\n                };\n                if (!this[elementsymbol]) {\n                    const innervdom = this[inner_vdom_symbol];\n                    if (innervdom) {\n                        this[elementsymbol] = render(innervdom).flat(Infinity);\n                        this[inner_vdom_symbol] = [];\n                    }\n                }\n                const css = get(this.constructor, \"css\");\n                const prefix = this.tagName.toLowerCase();\n                if (css) {\n                    const waitcallback = this[waittranformcsssymbol];\n                    if (waitcallback) {\n                        waitcallback().then(thencallbackfirst).then(thencallbacksecond);\n                    } else {\n                        Promise.resolve(thencallbackfirst).then(thencallbacksecond);\n                    }\n                } else {\n                    mountrealelement(this[elementsymbol], this);\n                }\n            }\n            connectedCallback() {\n                setimmediate(() => {\n                    connectedCallback(this);\n                });\n            }\n            disconnectedCallback() {\n                setimmediate(() => {\n                    disconnectedCallback(this);\n                });\n            }\n            [attributeChangedCallback](name) {\n                if (this[readysymbol]) {\n                    {\n                        const propreactivestate = this[attributessymbol][name];\n                        if (propreactivestate) {\n                            propreactivestate[dispatchsymbol]();\n                        }\n                    }\n                }\n            }\n        }\n        Component[_b] = componentsymbol;\n        Component.css = isstring(css) && css ? css : undefined;\n        Component.defaultProps = isobject(defaultProps) ? JSON.parse(JSON.stringify(defaultProps)) : undefined;\n        cached_create_componet.set(custfun, Component);\n        return Component;\n    } else {\n        console.error(custfun);\n        console.error(invalid_Function);\n        throw TypeError();\n    }\n}\n\nconst createComponent = custfun => autocreateclass(custfun);\n\nfunction autocreateclass(custfun) {\n    if (isclassextendsHTMLElement(custfun)) {\n        return custfun;\n    } else if (isfunction(custfun)) {\n        return createComponentold(custfun);\n    } else {\n        throw TypeError();\n    }\n}\n\nfunction h(type, propsorchildren, ...children) {\n    if (isfunction(type)) {\n        type = autocreateclass(type);\n    }\n    if (isarray(propsorchildren)) {\n        return apply(createElement, undefined, [ type, undefined, [ ...propsorchildren, ...children ].flat(1 / 0) ]);\n    } else {\n        return apply(createElement, undefined, [ type, propsorchildren, ...children ]);\n    }\n}\n\nfunction createElement(type, props = {}, ...children) {\n    let typenormalized = isstring(type) || isfunction(type) ? type : \"\";\n    const propsnormalized = isplainobject(props) ? props : {};\n    const childrennormalized = children.flat(Infinity).map(a => a === 0 ? \"0\" : a).filter(a => !!a);\n    if (isstring(typenormalized)) {\n        typenormalized = typenormalized.trim().toLowerCase();\n    }\n    if (\"\" === typenormalized) {\n        return childrennormalized;\n    } else {\n        return apply(createVirtualElement, undefined, [ typenormalized, propsnormalized, childrennormalized ]);\n    }\n}\n\nconst invalid_ReactiveState = \"invalid ReactiveState\";\n\nconst truevdomsymbol = Symbol(\"truevdom\");\n\nconst falsevdomsymbol = Symbol(\"falsevdom\");\n\nconst trueelesymbol = Symbol(\"trueele\");\n\nconst falseelesymbol = Symbol(\"falseele\");\n\nconst handletrue = Symbol(\"handletrue\");\n\nconst handlefalse = Symbol(\"handlefalse\");\n\nconst currentelementsymbol = Symbol(\"currentelement\");\n\nconst Condition = function(conditon, iftrue, iffalse) {\n    var _a, _b, _c, _d, _e;\n    if (!(isReactiveState(conditon) || isboolean(conditon))) {\n        console.error(conditon);\n        console.error(invalid_ReactiveState);\n        throw TypeError();\n    }\n    [ iftrue, iffalse ].forEach(a => {\n        if (!(isundefined(a) || isVirtualdom(a) || isstring(a))) {\n            console.error(a);\n            console.error(invalid_Virtualdom);\n            throw new TypeError;\n        }\n    });\n    const optionstrue = iftrue;\n    const optionsfalse = iffalse;\n    class Condition extends AttrChange {\n        constructor() {\n            super(...arguments);\n            this[_a] = this;\n            this[_c] = false;\n            this[_d] = toArray(optionstrue);\n            this[_e] = toArray(optionsfalse);\n        }\n        [(_a = currentelementsymbol, _b = componentsymbol, _c = readysymbol, _d = truevdomsymbol, \n        _e = falsevdomsymbol, handlefalse)]() {\n            if (!this[falseelesymbol]) {\n                this[falseelesymbol] = render(this[falsevdomsymbol]);\n                this[falsevdomsymbol] = [];\n            }\n            const elementtomount = this[falseelesymbol][0] || this;\n            replaceChild(elementtomount, this[currentelementsymbol]);\n            this[currentelementsymbol] = elementtomount;\n        }\n        [handletrue]() {\n            if (!this[trueelesymbol]) {\n                this[trueelesymbol] = render(this[truevdomsymbol]);\n                this[truevdomsymbol] = [];\n            }\n            const elementtomount = this[trueelesymbol][0] || this;\n            replaceChild(elementtomount, this[currentelementsymbol]);\n            this[currentelementsymbol] = elementtomount;\n        }\n        [firstinstalledcallback]() {\n            const handleconditionchange = trueorfalse => {\n                if (true === trueorfalse) {\n                    get(this, handletrue).call(this);\n                } else if (!trueorfalse) {\n                    get(this, handlefalse).call(this);\n                }\n            };\n            if (isReactiveState(conditon)) {\n                handleconditionchange(conditon.valueOf());\n                watch(conditon, trueorfalse => {\n                    handleconditionchange(trueorfalse);\n                });\n            } else {\n                handleconditionchange(conditon);\n            }\n        }\n        connectedCallback() {\n            connectedCallback(this);\n        }\n        disconnectedCallback() {\n            disconnectedCallback(this);\n        }\n    }\n    Condition[_b] = componentsymbol;\n    const vdom = h(Condition);\n    return vdom;\n};\n\nconst cancel_watch_symbol = Symbol(\"cancel_watch\");\n\nconst cached_class_element = Symbol(\"cached_class_element\");\n\nconst switch_mount_symbol = Symbol(\"switch_mount\");\n\nfunction Switchable(funstate) {\n    var _a, _b, _c;\n    if (!isReactiveState(funstate)) {\n        console.error(funstate);\n        throw new TypeError;\n    }\n    class Switchable extends AttrChange {\n        constructor() {\n            super(...arguments);\n            this[_a] = new WeakMap;\n            this[_c] = false;\n        }\n        disconnectedCallback() {\n            setimmediate(() => {\n                disconnectedCallback(this);\n                if (isfunction(this[cancel_watch_symbol])) {\n                    this[cancel_watch_symbol]();\n                }\n            });\n        }\n        [(_a = cached_class_element, _b = componentsymbol, _c = readysymbol, switch_mount_symbol)](eleclass) {\n            eleclass = autocreateclass(eleclass);\n            const eleme = this[cached_class_element].get(eleclass);\n            if (eleme) {\n                mountrealelement(eleme, this);\n            } else {\n                const elementreal = render(h(eleclass));\n                this[cached_class_element].set(eleclass, elementreal);\n                mountrealelement(elementreal, this);\n            }\n        }\n        [firstinstalledcallback]() {\n            const callmountswitch = () => {\n                this[switch_mount_symbol](funstate.valueOf());\n            };\n            callmountswitch();\n            this[cancel_watch_symbol] = watch(funstate, () => {\n                callmountswitch();\n            });\n        }\n        connectedCallback() {\n            connectedCallback(this);\n        }\n    }\n    Switchable[_b] = componentsymbol;\n    return h(Switchable);\n}\n\nvar n$1 = function(t, s, r, e) {\n    var u;\n    s[0] = 0;\n    for (var h = 1; h < s.length; h++) {\n        var p = s[h++], a = s[h] ? (s[0] |= p ? 1 : 2, r[s[h++]]) : s[++h];\n        3 === p ? e[0] = a : 4 === p ? e[1] = Object.assign(e[1] || {}, a) : 5 === p ? (e[1] = e[1] || {})[s[++h]] = a : 6 === p ? e[1][s[++h]] += a + \"\" : p ? (u = t.apply(a, n$1(t, a, r, [ \"\", null ])), \n        e.push(u), a[0] ? s[0] |= 2 : (s[h - 2] = 0, s[h] = u)) : e.push(a);\n    }\n    return e;\n}, t$1 = new Map;\n\nfunction htm(s) {\n    var r = t$1.get(this);\n    return r || (r = new Map, t$1.set(this, r)), (r = n$1(this, r.get(s) || (r.set(s, r = function(n) {\n        for (var t, s, r = 1, e = \"\", u = \"\", h = [ 0 ], p = function(n) {\n            1 === r && (n || (e = e.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g, \"\"))) ? h.push(0, n, e) : 3 === r && (n || e) ? (h.push(3, n, e), \n            r = 2) : 2 === r && \"...\" === e && n ? h.push(4, n, 0) : 2 === r && e && !n ? h.push(5, 0, !0, e) : r >= 5 && ((e || !n && 5 === r) && (h.push(r, 0, e, s), \n            r = 6), n && (h.push(r, n, 0, s), r = 6)), e = \"\";\n        }, a = 0; a < n.length; a++) {\n            a && (1 === r && p(), p(a));\n            for (var l = 0; l < n[a].length; l++) t = n[a][l], 1 === r ? \"<\" === t ? (p(), h = [ h ], \n            r = 3) : e += t : 4 === r ? \"--\" === e && \">\" === t ? (r = 1, e = \"\") : e = t + e[0] : u ? t === u ? u = \"\" : e += t : '\"' === t || \"'\" === t ? u = t : \">\" === t ? (p(), \n            r = 1) : r && (\"=\" === t ? (r = 5, s = e, e = \"\") : \"/\" === t && (r < 5 || \">\" === n[a][l + 1]) ? (p(), \n            3 === r && (h = h[0]), r = h, (h = h[0]).push(2, 0, r), r = 0) : \" \" === t || \"\\t\" === t || \"\\n\" === t || \"\\r\" === t ? (p(), \n            r = 2) : e += t), 3 === r && \"!--\" === e && (r = 4, h = h[0]);\n        }\n        return p(), h;\n    }(s)), r), arguments, [])).length > 1 ? r : r[0];\n}\n\nfunction htmlold(...inargs) {\n    return apply(htm, h, inargs);\n}\n\nfunction html(...args) {\n    const prevdom = toArray(htmlold(...args));\n    const vdom = prevdom.length === 1 ? prevdom[0] : prevdom;\n    if (isvalidvdom(vdom)) {\n        return vdom;\n    } else {\n        console.error(vdom);\n        console.error(invalid_Virtualdom);\n        throw new TypeError;\n    }\n}\n\nfunction createRef(value) {\n    return {\n        value: value\n    };\n}\n\nfunction extenddirectives(name, fun) {\n    if (!isstring(name)) {\n        console.error(name);\n        throw new TypeError;\n    }\n    if (typeof fun !== \"function\") {\n        console.error(fun);\n        console.error(invalid_Function);\n        throw TypeError();\n    } else {\n        if (!directive[name]) {\n            Reflect.set(directive, name, fun);\n        } else {\n            console.error(directive);\n            console.error(\"can not extend existing directive\");\n            throw new Error;\n        }\n    }\n}\n\nfunction model(types, bindattribute, domprop, eventnames, value, vdom) {\n    if (!isReactiveState(value)) {\n        console.error(value);\n        console.error(invalid_ReactiveState + invalid_Virtualdom);\n        throw TypeError();\n    }\n    if (types.includes(vdom.type)) {\n        set(vdom.bindattr, bindattribute, value);\n        eventnames.forEach(eventname => {\n            const origin = vdom.onevent[eventname];\n            const eventsarray = toArray(origin);\n            set(vdom.onevent, eventname, toArray([ ...eventsarray, e => value.value = get(e.target, domprop) ]).filter(Boolean));\n        });\n    } else {\n        console.error(vdom);\n        console.error(invalid_ReactiveState + invalid_Virtualdom);\n        throw TypeError();\n    }\n}\n\nconst Localchecked = (value, element, vdom) => {\n    if (!isReactiveState(value)) {\n        throw new TypeError;\n    }\n    console.log(element);\n    model([ \"input\" ], \"checked\", \"checked\", [ \"change\" ], value, vdom);\n    const eventname = \"click\";\n    const origin = toArray(vdom.onevent[eventname]);\n    const eventsarray = origin;\n    const dispatchallsamename = event => {\n        const inputelement = event.target;\n        const name = event.target.name;\n        if (name) {\n            querySelectorAll(`input[name=${name}]`).filter(ele => ele !== inputelement).forEach(element => {\n                element.dispatchEvent(new Event(\"change\"));\n            });\n        }\n    };\n    set(vdom.onevent, eventname, toArray([ ...eventsarray, dispatchallsamename ]).filter(Boolean));\n};\n\nconst Localcreated = (call, ele, vdom, onmount, onunmount, onupdated) => {\n    console.log([ call, ele, vdom, onmount, onunmount, onupdated ]);\n    if (typeof call === \"function\") {\n        call();\n    } else {\n        throw new TypeError;\n    }\n};\n\nfunction getproperyreadproxy(a) {\n    const __proto__ = \"__proto__\";\n    const target = a;\n    return new Proxy(target, {\n        getOwnPropertyDescriptor(target, key) {\n            if (issymbol(key)) {\n                return;\n            } else {\n                return getOwnPropertyDescriptor(target, key);\n            }\n        },\n        ownKeys(target) {\n            let myvalue = get(target, \"value\");\n            const myvalueobj = isobject(myvalue) ? myvalue : myvalue[__proto__];\n            return Array.from(new Set([ ...ownKeys(target), ...ownKeys(myvalueobj) ]));\n        },\n        has(target, key) {\n            const myvalue = get(target, \"value\");\n            const myvalueobj = isobject(myvalue) ? myvalue : myvalue[__proto__];\n            return has(target, key) || has(myvalueobj, key);\n        },\n        get(target, key) {\n            if (has(target, key)) {\n                return get(target, key);\n            } else {\n                const myvalue = get(target, \"value\");\n                const myvalueobj = Object(myvalue);\n                if (has(myvalueobj, key)) {\n                    const property = get(myvalueobj, key);\n                    return isfunction(property) ? property.bind(myvalueobj) : property;\n                }\n            }\n        }\n    });\n}\n\nconst computed = function(state, callback, setter) {\n    if (!((isarray(state) || isReactiveState(state)) && isfunction(callback))) {\n        console.error(state);\n        console.error(callback);\n        console.error(invalid_ReactiveState + invalid_Function);\n        throw TypeError();\n    }\n    const state1array = toArray(state);\n    if (!state1array.length) {\n        console.error(\"Empty array not allowed\");\n        throw new Error;\n    }\n    const state1 = Arraycomputed(state1array, callback, setter);\n    return state1;\n};\n\nfunction Arraycomputed(state, callback, setter) {\n    const reactivestate = new ReactiveState;\n    const getter = () => {\n        const value = apply(callback, undefined, state.map(st => st.valueOf()));\n        const possiblevalue = isReactiveState(value) ? value.valueOf() : value;\n        if (isobject(possiblevalue) || isprimitive(possiblevalue)) {\n            return possiblevalue;\n        } else {\n            console.error(possiblevalue);\n            throw TypeError();\n        }\n    };\n    let memorized = getter();\n    defineProperty(reactivestate, \"value\", {\n        set: isfunction(setter) ? setter : undefined,\n        get: getter,\n        configurable: true\n    });\n    state.forEach(state => {\n        watch(state, () => {\n            let newvalue = getter();\n            if (newvalue !== memorized) {\n                reactivestate[dispatchsymbol]();\n                memorized = newvalue;\n            }\n        });\n    });\n    return getproperyreadproxy(reactivestate);\n}\n\nconst localfor = (value, ele, vdom, onmount, onunmount, onupdated) => {\n    if (!Array.isArray(value)) {\n        throw TypeError();\n    }\n    const [list, fun] = value;\n    if (!isReactiveState(list) || !isfunction(fun)) {\n        throw TypeError();\n    }\n    vdom.children.length = 0;\n    const changecallback = () => {\n        const data = list.valueOf();\n        if (!isarray(data)) {\n            throw TypeError();\n        }\n        const oldlength = ele.childNodes.length;\n        const newlength = data.length;\n        const minlength = Math.min(oldlength, newlength);\n        if (newlength < oldlength) {\n            ele.childNodes.forEach((n, i) => {\n                if (i > minlength - 1) {\n                    removeNode(n);\n                }\n            });\n        } else if (newlength > oldlength) {\n            const childs = generatechildrenvdoms(list, fun);\n            const nodes = render(childs.slice(minlength));\n            nodes.forEach((n, i) => {\n                ele.appendChild(n);\n            });\n        }\n    };\n    console.log(value, ele, vdom, onmount, onunmount, onupdated);\n    onmount(changecallback);\n    onmount(() => {\n        const cancel = watch(list, changecallback);\n        onunmount(cancel);\n    });\n};\n\nfunction generatechildrenvdoms(liststate, fun) {\n    const data = liststate.valueOf();\n    const childs = new Array(data.length).fill(undefined).map((v, index) => {\n        const vdom = Reflect.apply(fun, undefined, [ computed(liststate, arr => arr[index]), index ]);\n        if (!isVirtualdom(vdom)) {\n            throw new TypeError;\n        }\n        return vdom;\n    });\n    return childs;\n}\n\nfunction createhtmlandtextdirective(seteletext, errorname, ele, text, onmount, onunmount) {\n    {\n        const element = ele;\n        if (isstring(text)) {\n            requestAnimationFrame(() => {\n                seteletext(ele, text);\n            });\n        } else if (isReactiveState(text)) {\n            onmount(() => {\n                const cancel = watch(text, () => {\n                    const state = text;\n                    if (isconnected(element)) {\n                        seteletext(ele, String(state));\n                    }\n                });\n                onunmount(cancel);\n            });\n            requestAnimationFrame(() => {\n                seteletext(ele, String(text));\n            });\n        } else {\n            console.error(text);\n            console.error(\"invalid \" + errorname);\n            throw TypeError();\n        }\n    }\n}\n\nconst Localhtml = (html, ele, vdom, onmount, onunmount) => {\n    if (isstring(html) || isReactiveState(html)) {\n        console.log(vdom);\n        vdom.children.length = 0;\n        createhtmlandtextdirective(setelehtml, \"html\", ele, html, onmount, onunmount);\n    } else {\n        throw new TypeError;\n    }\n};\n\nconst Localmounted = (call, ele, vdom, onmount, onunmount) => {\n    console.log([ call, ele, vdom, onmount, onunmount ]);\n    if (typeof call === \"function\") {\n        apply(onmount, undefined, [ call ]);\n    } else {\n        throw new TypeError;\n    }\n};\n\nconst Localref = (ref, ele, _vdom) => {\n    if (isfunction(ref)) {\n        apply(ref, undefined, [ ele ]);\n    } else if (isobject(ref)) {\n        set(ref, \"value\", ele);\n    } else {\n        console.log(_vdom);\n        console.error(ref);\n        console.error(\"invalid ref\");\n        throw TypeError();\n    }\n};\n\nconst Localtext = (text, ele, vdom, onmount, onunmount) => {\n    if (isstring(text) || isReactiveState(text)) {\n        console.log(vdom);\n        vdom.children.length = 0;\n        createhtmlandtextdirective(seteletext, \"text\", ele, text, onmount, onunmount);\n    } else {\n        throw new TypeError;\n    }\n};\n\nconst Localunmounted = (call, ele, vdom, onmount, onunmount) => {\n    console.log([ call, ele, vdom, onmount, onunmount ]);\n    if (typeof call === \"function\") {\n        apply(onunmount, undefined, [ call ]);\n    } else {\n        throw new TypeError;\n    }\n};\n\nconst Localupdated = (call, ele, vdom, onmount, onunmount, onupdated) => {\n    console.log([ call, ele, vdom, onmount, onunmount ]);\n    if (typeof call === \"function\") {\n        apply(onupdated, undefined, [ call ]);\n    } else {\n        throw new TypeError;\n    }\n};\n\nconst Localvalue = (value, element, vdom) => {\n    if (isReactiveState(value)) {\n        console.log(element);\n        model([ \"input\", \"textarea\", \"select\" ], \"value\", \"value\", [ \"change\", \"input\" ], value, vdom);\n    } else {\n        throw new TypeError;\n    }\n};\n\nextenddirectives(\"ref\", Localref);\n\nextenddirectives(\"html\", Localhtml);\n\nextenddirectives(\"text\", Localtext);\n\nextenddirectives(\"value\", Localvalue);\n\nextenddirectives(\"checked\", Localchecked);\n\nconst Directives = extenddirectives;\n\nDirectives(\"mounted\", Localmounted);\n\nDirectives(\"unmounted\", Localunmounted);\n\nDirectives(\"updated\", Localupdated);\n\nDirectives(\"created\", Localcreated);\n\nextenddirectives(\"for\", localfor);\n\nfunction useCreated(fun) {\n    createdctx.add(fun);\n}\n\nfunction useUpdated(fun) {\n    updatedctx.add(fun);\n}\n\nfunction useMounted(fun) {\n    mountedctx.add(fun);\n}\n\nfunction useUnMounted(fun) {\n    unmountedctx.add(fun);\n}\n\nconst e$1 = Set.prototype, t$2 = Map.prototype;\n\nfunction r$1(e) {\n    return e instanceof Map;\n}\n\nfunction o$1(e) {\n    return e instanceof Set;\n}\n\nfunction n$2(e) {\n    return Array.isArray(e);\n}\n\nconst l$1 = window.Reflect, {ownKeys: i$1, deleteProperty: c$1, apply: a$1, construct: d$1, defineProperty: f$1, get: u$1, getOwnPropertyDescriptor: p$1, getPrototypeOf: s$1, has: y$1, set: v, setPrototypeOf: g$1} = l$1;\n\nfunction P(e) {\n    return \"object\" == typeof e && null !== e;\n}\n\nfunction w$1(e) {\n    return \"function\" == typeof e;\n}\n\nfunction S(l, h, O = [], x = l) {\n    if (!w$1(h)) throw Error();\n    if (l instanceof Promise || function(e) {\n        return e instanceof RegExp;\n    }(l) || function(e) {\n        return e instanceof Date;\n    }(l)) return l;\n    if (w$1(l) || P(l)) {\n        let E;\n        return o$1(l) ? (E = new Set([ ...l ]), v(E, \"add\", t => (e$1.add.call(l, t), h(x, O, void 0, void 0), \n        e$1.add.call(E, t))), v(E, \"delete\", t => (e$1.delete.call(l, t), h(x, O, void 0, void 0), \n        e$1.delete.call(E, t))), v(E, \"clear\", () => (e$1.clear.call(l), h(x, O, void 0, void 0), \n        e$1.clear.call(E)))) : r$1(l) ? (E = new Map([ ...l ]), v(E, \"clear\", () => (t$2.clear.call(l), \n        h(x, O, void 0, void 0), t$2.clear.call(E))), v(E, \"set\", (e, r) => (t$2.set.call(l, e, r), \n        h(x, O, void 0, void 0), t$2.set.call(E, e, r))), v(E, \"delete\", e => (t$2.delete.call(l, e), \n        h(x, O, void 0, void 0), t$2.delete.call(E, e)))) : E = n$2(l) ? [] : w$1(l) ? () => {} : {}, \n        o$1(l) || r$1(l) || g$1(E, null), new Proxy(E, {\n            defineProperty: (e, t, r) => (h(x, [ ...O, String(t) ], y$1(r, \"value\") ? r.value : w$1(r.get) ? r.get() : void 0, u$1(l, t)), \n            f$1(l, t, r)),\n            deleteProperty: (e, t) => (h(x, [ ...O, String(t) ], void 0, u$1(l, t)), c$1(l, t)),\n            ownKeys: () => i$1(l),\n            has: (e, t) => y$1(l, t),\n            getPrototypeOf: () => s$1(l),\n            setPrototypeOf: (e, t) => g$1(l, t),\n            construct(e, t) {\n                if (w$1(l)) return d$1(l, t);\n            },\n            apply(e, t, r) {\n                if (w$1(l)) return a$1(l, t, r);\n            },\n            getOwnPropertyDescriptor(e, t) {\n                var r = p$1(l, t);\n                return n$2(l) && \"length\" === t ? r : r ? (r.configurable = !0, r) : void 0;\n            },\n            set: (e, t, r) => (w$1(h) && h(x, [ ...O, String(t) ], r, u$1(l, t)), v(l, t, r)),\n            get(e, t) {\n                var n = u$1(l, t);\n                return w$1(n) && (o$1(l) || r$1(l)) ? u$1(E, t).bind(E) : w$1(n) || P(n) ? S(n, h, [ ...O, String(t) ], l) : n;\n            }\n        });\n    }\n    return l;\n}\n\nfunction deepobserve(e, t) {\n    if (!w$1(t)) throw Error();\n    if (!w$1(Proxy)) throw Error();\n    return w$1(e) || P(e) ? S(e, t) : e;\n}\n\nfunction handleobjectstate(init) {\n    const reactive = new ReactiveState(init);\n    let initobj = init;\n    const containReactiveState = isplainobject(init) && Object.values(init).some(a => isReactiveState(a));\n    const state_entries = Object.entries(init).filter(e => {\n        const a = e[1];\n        return isReactiveState(a);\n    });\n    if (containReactiveState) {\n        initobj = Object.assign({}, init);\n        state_entries.forEach(([key, state]) => {\n            defineProperty(initobj, key, {\n                enumerable: true,\n                get() {\n                    return state.valueOf();\n                },\n                set: nvalue => {\n                    state.value = nvalue;\n                },\n                configurable: true\n            });\n        });\n    }\n    if (containReactiveState) {\n        state_entries.forEach(([key, state]) => {\n            watch(state, () => {\n                reactive[dispatchsymbol]();\n            });\n        });\n    }\n    reactive.value = initobj;\n    const objproxyhandler = {};\n    objproxyhandler.ownKeys = target => Array.from(new Set([ ...ownKeys(target), ...ownKeys(get(target, \"value\")) ]));\n    objproxyhandler.setPrototypeOf = () => false;\n    objproxyhandler.defineProperty = () => false;\n    objproxyhandler.getOwnPropertyDescriptor = (target, key) => {\n        if (issymbol(key)) {\n            return;\n        }\n        const myvalue = get(target, \"value\");\n        const descripter = getOwnPropertyDescriptor(target, key) || getOwnPropertyDescriptor(myvalue, key);\n        if (descripter) {\n            descripter.configurable = true;\n        }\n        return descripter;\n    };\n    objproxyhandler.deleteProperty = (target, key) => {\n        const myvalue = get(target, \"value\");\n        if (has(myvalue, key)) {\n            deleteProperty(myvalue, key);\n            target[dispatchsymbol]();\n            return true;\n        } else {\n            return true;\n        }\n    };\n    objproxyhandler.has = (target, key) => {\n        const myvalue = get(target, \"value\");\n        return has(target, key) || has(myvalue, key);\n    };\n    objproxyhandler.get = (target, key) => {\n        const value = get(target, \"value\");\n        const deepflage = isarray(value) || isplainobject(value);\n        if (key === \"value\" && deepflage) {\n            return deepobserve(get(target, key), (_target_, patharray) => {\n                target[dispatchsymbol]();\n            });\n        } else if (has(target, key)) {\n            return get(target, key);\n        } else if (has(value, key)) {\n            const resultvalue = get(value, key);\n            if (isSet(value)) {\n                if (key === \"add\" || key === \"clear\" || key === \"delete\") {\n                    switch (key) {\n                      case \"add\":\n                        {\n                            return (add => {\n                                if (!set_prototype.has.call(value, add)) {\n                                    const returnvalue = set_prototype[key].call(value, add);\n                                    target[dispatchsymbol]();\n                                    return returnvalue;\n                                }\n                                return;\n                            }).bind(value);\n                        }\n\n                      case \"delete\":\n                        {\n                            return (dele => {\n                                if (set_prototype.has.call(value, dele)) {\n                                    const returnvalue = set_prototype[key].call(value, dele);\n                                    target[dispatchsymbol]();\n                                    return returnvalue;\n                                }\n                                return;\n                            }).bind(value);\n                        }\n\n                      case \"clear\":\n                        {\n                            return (() => {\n                                if (value.size) {\n                                    const returnvalue = set_prototype[key].call(value);\n                                    target[dispatchsymbol]();\n                                    return returnvalue;\n                                }\n                                return;\n                            }).bind(value);\n                        }\n                    }\n                } else {\n                    return isfunction(resultvalue) ? resultvalue.bind(value) : resultvalue;\n                }\n            } else if (deepflage && (isarray(resultvalue) || isplainobject(resultvalue))) {\n                return deepobserve(resultvalue, () => {\n                    target[dispatchsymbol]();\n                });\n            } else {\n                return resultvalue;\n            }\n        }\n    };\n    objproxyhandler.set = (target, key, value) => {\n        if (isReactiveState(value)) {\n            value = value.valueOf();\n        }\n        const myvalue = get(target, \"value\");\n        if (key === \"value\" && isobject(value) && (isarray(init) && isarray(value) || !isarray(init) && !isarray(value))) {\n            if (target[key] !== value) {\n                set(target, key, value);\n                target[dispatchsymbol]();\n            }\n            return true;\n        } else if (!has(target, key)) {\n            if (myvalue[key] !== value) {\n                set(myvalue, key, value);\n                target[dispatchsymbol]();\n            }\n            return true;\n        } else {\n            console.error(value);\n            console.error(init);\n            console.error(invalid_primitive_or_object_state);\n            throw TypeError();\n        }\n    };\n    return new Proxy(reactive, objproxyhandler);\n}\n\nconst set_prototype = Set.prototype;\n\nfunction createState(init) {\n    if (isprimitive(init) || isfunction(init)) {\n        return getproperyreadproxy(new Proxy(new ReactiveState(init), {\n            defineProperty() {\n                return false;\n            },\n            deleteProperty() {\n                return false;\n            },\n            set(target, key, value) {\n                if (key === \"value\" && (isprimitive(value) && isprimitive(init) || isfunction(value) && isfunction(init))) {\n                    if (target[key] !== value) {\n                        set(target, key, value);\n                        target[dispatchsymbol]();\n                    }\n                    return true;\n                } else {\n                    console.error(value);\n                    console.error(init);\n                    console.error(invalid_primitive_or_object_state);\n                    throw TypeError();\n                }\n            },\n            setPrototypeOf() {\n                return false;\n            }\n        }));\n    } else if (isReactiveState(init)) {\n        return createState(init.valueOf());\n    } else if (isobject(init)) {\n        return handleobjectstate(init);\n    } else {\n        throw Error();\n    }\n}\n\nexport { Condition, extenddirectives as Directives, MountElement, Switchable, computed, createComponent, h as createElement, createRef, createState, h, html, render, useCreated, useMounted, useUnMounted, useUpdated, watch };\n//# sourceMappingURL=index.js.map\n"],"names":["a","isString","isnumber","isboolean","isundefined","isbigint"],"mappings":"wUAEwBA,UAEhBC,EAASD,IACTE,EAASF,IACTG,EAAUH,IACVI,EAAYJ,aAIKA,SACD,iBAANA,EAJVK,CAASL"}